First 5 bits detail the opcode (operation code / instruction code)
registers are 5 bits
addresses are 22 bits

Operations

HLT (halt) = (opcode) 00000 (remaining bits are undefined for now)

MOV (move value at adress into register) = (opcode) 00001 (register) xxxxx (address)

ADD = (opcode) 00010 (register 1, where result is stored) xxxxx (register 2) xxxxx (remaining bits are undefined for now) -> register1 = register1 + register2

CMP (compare) = (opcode) 00011 (register1) xxxxx (register2) xxxxx (remaining bits are undefined for now)

JMP (jump) = (opcode) 00100 (address) (remaining bits are undefined for now)

SUB (subtract) = (opcode) 00101 (register1) xxxxx (register2) xxxxx (remaining bits are undefined for now) -> register1 = register1 - register2

LEA (load effective address) = (opcode) 00110 (register) xxxxx (moves the specified address into the specified register. The effective address part refers to the fact that this is the absolute position in memory.)
*Note: LEA can be used to move values directly into specific registers from the code if you do not want to first grab data from memory. 

STORE (put value in register at specified memory location) = (opcode) 00111 (register) xxxxx (address)

LBITSHFTR (logical bit shift right 1, meaning right is filled with 0s) = (opcode) 01000 (register1) xxxxx (register2) xxxxx (remaining bits are undefined for now)
*Note: register1 = register1 = register1 >> register2 (register1 is bitshifted right the number of times of the value in register2, and the result in stored in register1)

BITSHFTL (bit shift left 1) = (opcode) 01001 (register) xxxxxx (register) xxxxxx (remaining bits are undefined for now)

AND (bitwise and) = (opcode) 01010 (register1) xxxxxx (register2) xxxxxx (remaining bits are undefined for now) -> result is stored in register1

XOR (bitiwse xor) = (opcode) 01011 (register1) xxxxxx (register2) xxxxxx (remaining bits are undefined for now) -> results is stored in register1

OR (bitwise or) = (opcode) 01100 (register1) xxxxxx (register2) xxxxxx (remaining bits are undefined for now) -> results is stored in register1

NOT (bitwise not) = (opcode) 01101 (register1) xxxxxx (register2) xxxxxx (remaining bits are undefined for now) -> results is stored in register1

EQU (equals) = (opcode) 01110 (register1) xxxxx (register2) xxxxx (remaining bits are undefined for now) -> register1 = register2 (value in register1 set to value in register2)

Register Information

*Note: The following register purposes are conventions based on real computers. They have predefined
purposes, but can in general be used with any of the operations pertaining to the registers.

rax = accumulator register (used for storing intermediate results of arithmetic and logical operations) = 00000

rbx = base register (used for storing memory address of first location of data in program. You can then access data relative to the base register) = 00001

rcx = program counter register (can be used a counter or to hold intermediate value during calculation) = 00010

rdx = data register (store and manipulate data with this register) = 00011

rsi = source index register (useful for storing memory address of source array) = 00100

rdi = destination index register (useful for storing memory adddress of desitnation or target array) = 00101

rbp = base pointer register (points to the base of the stack (memory)) = 00110

rsp = stack pointer register (points to memory address of last item pushed onto stack) = 00111

The Next 8 registers are general purpose. Use them any way you'd like. (This is subject to change possibly)

r1 = 01000

r2 = 01001

r3 = 01010

r4 = 01011

r5 = 01100

r6 = 01101

r7 = 01110

r8 = 01111

rip = 10000 = instruction pointer (stores the next instruction to be executed. Can also be used for relative addressing. Should not be modified directly)



